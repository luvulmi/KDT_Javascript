// 달팽이 구조.

// 맨 처음 반복되는 구조를 찾아라.
// 행과 열의 관계성 파악
// 관계성 파악 조건 : 두 값의 합, 두 값의 차, 두 값의 동일성
// 반복되는 규칙 발견 > 반복문 사용.
// 반복되는 회전 수 파악.
// 증감여부 파악.

// 규칙성
// 1. i열 = i+1열 값이 동일.
// 2. (i행 - i+1행) = |1|

// 저장구조
// 행 고정구조 > 행이 고정되면 열이 변함.
// 열 고정구조 > 열이 고정되면 행이 변함.
// 전체구조 안에서 행 고정구조, 열 고정구조가 반복되는 로직.

// 변수 선언
// 규칙성 변수 : 행(r), 열(c)
// 회전수 변수 : s
// 증감변수 : f

// 구현절차
// 1) 구하는 식 찾기 > 행 고정구조, 열 고정구조 식 찾기
// 2) 생성식 찾기 > 값이 변하면 생성식 필요
// 3) 세부구조 확정
// 4) 초기값

// 생성식
// 변수들과 연관지어 생성.
// 생성식은 위치상관 없으나 본 문제 구조의 규칙성은 열이 변하면 고정 열과 동일해야함.
// 열 생성식은 상단에 배치해야함. 하단에 배치할 경우 값이 변하고 이동하므로 안됨.
// v 생성식은 하단에 배치.
// f 생성식은 외부에 위치해야함.

//  회전수로 이용할 변수가 없음.
// 새로운 변수 i 생성.
// s는 회전수 종료값.

// 전체 외곽구조 변수
// 반복 : 처음 / 끝 / 일정한 규칙
// s가 해당. s = 5
// 행 구조 열 구조 사이

// 초기값
// 행값 = 0 , 열값 = -1, 숫자값 = 1, 증감여부 = 1

'use strict';

const a = new Array(5);
for (let i = 0; i < a.length; i++) {
    a[i] = new Array(5);
}

let s = 5;
let r = 0, c = -1;
let v = 1;
let f = 1;

for (; ;) {
    for (let i = 0; i < s; i++) a[r][c += f] = v++;

    if (--s <= 0) break; // --s 먼저 감소해야하므로.

    for (let i = 0; i < s; i++) a[r += f][c] = v++;

    f = -f;
}

for (let i = 0, av; i < a.length; i++) {
    for (let j = 0; j < a[i].length; j++) {
        av = a[i][j];
        document.write(`${av / 10 < 1 ? '&nbsp;' : ''}${av} `);
    }
    document.write('<br/>');
}